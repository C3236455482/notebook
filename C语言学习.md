# C语言学习

#### VS源文件中如何使用自己写的头文件

- 一个完整的头文件应该分为：`.h`文件与`.cpp`文件

> 一般来说函数的声明，类（结构体）的定义都是放在`.h`头文件中，而函数的实现则是写在对应的`.cpp`文件中，什么个对应法呢，就是头文件文件名与`.cpp`文件名相同。

> 上述`.cpp`文件是c++的源文件，也可以是`.c`c语言的源文件。

> 在引用自己写的头文件时是` include " 自己的头文件名"`，而不是`include< >`(该方法只能引用系统定义的)

##### 建立一个头文件

头文件中按照如下格式来写入代码：

```c++
//Circle_queue 头文件名
#ifndef CIRCLE_QUEUE_H //就是头文件名(全大写后加个_H)

#define CIRCLE_QUEUE_H

//代码

#endif
```

> **将函数声明，类（结构体）定义写在头文件中**

##### 建立头文件对应的`.cpp`文件

>  源文件名与头文件名一定要相同!!!

在该文件中导入想对应的系统头文件，**以及我们创建的**。

> 然后在源文件写头文件中函数声明的实现



#### `malloc`函数用法

> `malloc`是C语言中用来动态分配内存的函数，它可以根据需要分配指定大小的内存空间，并返回一个指向该空间的指针。

`malloc`的用法如下：

首先，需要引入头文件`<stdlib.h>`或`<malloc.h>`。

##### 函数声明

`void *malloc(size_t size)`

##### 传入参数

然后，调用`malloc`函数，传入一个参数，表示要分配的内存空间的字节数。例如，如果要分配一个整数类型的空间，可以写`malloc(sizeof(int))`，其中`sizeof(int)`表示一个整数占用的字节数。

##### 返回值

> `malloc`函数会返回一个`void`*类型的指针，这是一个通用的指针类型，可以指向任何类型的数据。为了使用这个指针，**需要将它强制转换为所需的类型。***

*例如，如果要使用一个整数类型的指针，可以写(`int*)malloc(sizeof(int))`，其中(`int*)`表示将`void`*转换为`int*`。

> 如果`malloc`函数成功分配了内存空间，就会返回一个有效的指针地址，可以通过这个指针访问或修改分配的空间中的数据。

例如，如果要给分配的整数空间赋值为10，可以写`*(int*)malloc(sizeof(int)) = 10;`，其中*表示解引用操作符，用于访问指针所指向的数据。

`array = (int*)malloc(sizeof(int) * size);`

这个动态分配内存的语句，可以理解为array是一个指向一个整数数组的指针，这个数组的大小是size，也就是说，array可以访问和修改这个数组中的元素。(可以直接利用下标来访问)

**检查内存是否分配成功**

如果`malloc`函数分配失败，就会返回一个空指针NULL，表示没有可用的内存空间。这时候，需要检查返回值是否为NULL，并做相应的处理。例如，如果要判断分配是否成功，可以写

```c++
if ((int*)malloc(sizeof(int)) == NULL) 
	{ printf("内存分配失败"); } 
else 
	{ printf("内存分配成功"); }
```

**使用完释放空间**

使用完`malloc`函数分配的内存空间后，需要使用`free`函数释放它，以避免内存泄漏。`free`函数接受一个参数，就是要释放的指针地址。例如，如果要释放一个整数类型的指针p，可以写`free(p);`

> 释放完内存空间后，最好将指针置为NULL，以防止出现悬空指针或野指针。

例如，如果要将一个整数类型的指针p置为`NULL`，可以写`p = NULL;`



头文件：`ctype.h`  [ctype标准库函数](https://www.runoob.com/cprogramming/c-standard-library-ctype-h.html)
`isalpha()` 用来检测一个字符是否是字母，包括大写字母和小写字母。
`isalnum()` 检查所传的字符是否是字母和数字。
`islower()` 检查所传的字符是否是小写字母。	
`isupper()` 检查所传的字符是否是大写字母。	
`isdigit()` 检查所传的字符是否是十进制数字。
......



C语言库函数四舍五入

`round()` 函数: 将传入的小数四舍五入为最接近的整数。该函数需要用到`math.h`头文件

```c
y = round(x * 100) / 100; // 用round函数对x乘以100后的结果进行四舍五入，再除以100，得到保留两位小数的结果
```

`floor()` 函数: 将传入的小数向下取整为最接近的整数。该函数也需要用到`math.h`头文件

`ceil()` 函数: 将传入的小数向上取整为最接近的整数。该函数同样需要用到`math.h`头文件

手写实现方法
```c
int result = (int)(num + 0.5);
```





重复类型的代码用数组or函数

```c++
	int bills[7] = {100, 50, 20, 10, 5, 2, 1}; //用来存储钞票的面值
    int count[7] = {0}; //用来存储每种面值的张数
    for (int i = 0; i < 7; i++) {
        count[i] = money / bills[i]; 
        money = money % bills[i];
    }
```



灵活使用三目运算符

```c
if (w <= 100) // 首重100克以内
    {
        fee = (w + 19) / 20 * (k == 1 ? 0.8 : 1.2); 
    }
    else // 续重101～2000克
    {
        fee = 5 * (k == 1 ? 0.8 : 1.2) + (w - 100 + 99) / 100 * (k == 1 ? 1.2 : 2.0); 
    }
```



对于函数的封装!



闰年判断
```c
int is_leap_year(int year)
{
    // 闰年的判断规则是：能被4整除但不能被100整除，或者能被400整除
    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
}
```

C中想要直接使用bool,需包含`<stdbool.h> `库



声明一个字符串：`char* a = "abcdefg"；`
定义了一个字符串"abcdefg"，在连续的内存空间里存储，并且定义了一个保存这个字符串的首地址的指针变量a

声明一组字符串：`char* a[] = {"China","French","America","German"}；`
a[]是一个4长数组，里面存了四个指针变量：a[0],a[1],a[2],a[3]。分别指向字符串China，French，American和German的首地址。
而a[]的值也就是a也就是这个数组的首地址，也就是a[0]的地址。

查看这个字符型指针变量的字符串：`printf(%s,a);`



计算没有进位情况下加法的结果

```c
int simple_add(int a, int b) {
  int res = 0; 
  int base = 1; 
  while (a > 0 || b > 0) { 
    int x = a % 10; 
    int y = b % 10; 
    int z = (x + y) % 10; // 计算个位数字之和，取余数
    res += z * base; 
    a /= 10; 
    b /= 10; 
    base *= 10; 
  }
  return res; 
}
```



判断浮点数是否为0: `fabs(b) < 1e-12`



gcd

**利用辗转相除法和递归求最大公约数：两个整数的最大公约数等于其中较小的数和两数相除余数的最大公约数。**

如果a大于等于b，那么gcd(a, b)就等于gcd(b, a % b),这样就可以把较大的数a替换为较小的数a % b，从而缩小问题的规模。
如果a小于b，那么gcd(a, b)就等于gcd(b, a)，这样就可以交换a和b的值，**保证第一个参数不小于第二个参数**。

```c++
int gcd(int a, int b){
	return b == 0 ? a : gcd(b, a % b);
}
```



**循环算法（建议使用，最容易写的，也是效率最快的）**

```c++
ll gcd(ll a,ll b)
{
    while(b^=a^=b^=a%=b);
    return a;
}
```

`while(b^=a^=b^=a%=b);`
`b^=a^=b^=a` 这一串乍一看很复杂的代码其实就是把a和b的值交换了一下

**位同级运算符运算时从右往左看**: **算数运算 > 移位运算 > 位运算 > 逻辑运算**

`b^=a^=b^=a%=b` 首先是先将a=a%b，再进行a，b之间的交换，实现了上表的运算过程



异或交换的原理是基于异或运算的性质，即：

- 异或运算是一种按位运算，它的符号是^。异或运算的结果是1，当且仅当两个操作数的对应位是相反的。

- 异或运算满足交换律和结合律，即：

  `a ^ b = b ^ a  (a ^ b) ^ c = a ^ (b ^ c)`

- 异或运算有一个特殊的性质，就是任何数和自身进行异或运算，结果都是0。即：

  `a ^ a = 0`

- 由此可以推出，任何数和0进行异或运算，结果都是自身。即：

  `a ^ 0 = a`

利用这些性质，我们可以用异或运算来交换两个变量的值，而不需要使用第三个变量。假设我们有两个变量a和b，我们想要交换它们的值。我们可以这样做：

```C++
a = a ^ b; b = a ^ b; 
// 此时，b = (a ^ b) ^ b = a 
a = a ^ b; 
// 此时，a = (a ^ b) ^ a = b
```
