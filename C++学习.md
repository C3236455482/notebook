# C++学习



> 在C++类中,默认的数据成员的访问权限是私有访问权限。



##### 类和对象

```c
Person(const Person &p )
```

###### 拷贝构造函数为什么需要使用引用传递?

第一个原因是为了避免无限递归。如果拷贝构造函数的参数不加引用，而是直接传递一个对象，那么在调用拷贝构造函数时，就需要先用拷贝构造函数来创建一个临时对象，然后再把这个临时对象作为参数传递给拷贝构造函数。这样就会导致无限地调用拷贝构造函数，直到栈溢出。

第二个原因是为了提高效率。如果拷贝构造函数的参数不加引用，而是直接传递一个对象，那么在调用拷贝构造函数时，就需要先复制一份对象的数据，然后再把这份数据作为参数传递给拷贝构造函数。这样就会增加额外的内存分配和复制的开销。而如果拷贝构造函数的参数加了引用，那么在调用拷贝构造函数时，就只需要传递一个指向对象的地址，而不需要复制对象的数据。这样就可以节省内存和时间。



### C++ 保留两位小数（setprecision(n)的一些用法总结）

首先说C++代码

```c++
#include <iomanip>  //不要忘了头文件
```

```c++
//第一种写法
cout << setiosflags(ios::fixed) << setprecision(2);
//第二种写法
cout.setf(ios::fixed);
cout << setprecision(2);
//第三种写法
cout << fixed << setprecision(2);
```

要保留几位小数setprecision(n)的括号里n就换成几。
前两种写法是一样的，第三种是简化写的。
上面的语句写一次就行了，对之后的数字都有效。

只用setprecision(n)是控制保留**几位有效数字**
只是**四舍五入**修改了数字的**显示方法**，并不是修改原数字
如果要保留的太多，是不会补上0的
如果小数点前的位数多于你要保留位数，则会使用科学计数法

setprecision(n)和fixed合用的话可以**控制小数点后有几位**。然后你会发现，如果你要保留的位数多于数字原来的小数，就会补上0。

也可以使用cmath库中的round函数

